import Data.List
import Data.List.Split
import qualified Data.Set as Set

import Graphics.Gloss

-- represents a single point on the grid
type Position = (Int, Int)

-- represents a motion, ie U53
data Motion = Motion Char Int deriving Show

-- from a point, return a set of points generated by a motion
trace :: Position -> Motion -> [Position]
trace (sx, sy) (Motion 'U' distance) = [ (sx, sy + dy) | dy <- [1 .. distance] ]
trace (sx, sy) (Motion 'D' distance) = [ (sx, sy - dy) | dy <- [1 .. distance] ]
trace (sx, sy) (Motion 'R' distance) = [ (sx + dx, sy) | dx <- [1 .. distance] ]
trace (sx, sy) (Motion 'L' distance) = [ (sx - dx, sy) | dx <- [1 .. distance] ]

-- from a set of motions, generate an entire set of points representing a wire
-- assumes and origin of 0, 0
route :: [Motion] -> [Position]
route motions = foldl (\position motion -> position ++ (trace (last position) motion)) [(0, 0)] motions

-- get the manhattan distance between two points
manhattan :: Position -> Position -> Int
manhattan (x1, y1) (x2, y2) = (abs $ x1 - x2) + (abs $ y1 - y2)

-- get the intersections of multiple wires
crossings :: [[Motion]] -> [Position]
crossings instructions = Set.toList $ foldr1 Set.intersection $ map (\x -> Set.fromList $ route x) instructions

fromTuple :: Num a => (Int, Int) -> (a, a)
fromTuple (x, y) = (fromIntegral x, fromIntegral y)

drawVisualization instructions = pictures [ plotWire (red) (instructions !! 0)
                                          , plotWire (blue) (instructions !! 1)
                                          , plotPoints (green) (crossings instructions)]
  where plotWire c p = color c $ line $ map (fromTuple) $ justEnds $ route p
        plotPoints c points = pictures $ map (\(x, y) -> translate (fromIntegral x) (fromIntegral y) $ color c $ circle 10) points
        justEnds points = concat $ map (\l -> [head l, last l]) $ groupBy (\(x1, y1) (x2, y2) -> x1 == x2 || y1 == y2) points

main = do
  -- here, the file is being broken into lines, then each line is made into a set of motions by readWire
  instructions <- readFile "input" >>= (\x -> pure $ map (readWire) $ lines x)
  display (InWindow "wires!" (200, 200) (10, 10)) black (drawVisualization instructions)

  -- readWire splits a line on its commas, then reads in each element a a Motion
  where readWire definition = map (\x -> Motion (head x) (read $ tail x)) $ splitOn "," definition
